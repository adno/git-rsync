#!/usr/bin/env bash
#
# Copyright (c) 2021 Hiroyuki Deguchi
#
# This software is released under the MIT License.
# http://opensource.org/licenses/mit-license.php

set -e

function usage() {
    cat << _EOT_ >&2
git-rsync v0.0.1

Usage: $(basename $0) [-n] [-x <pattern>] <command> [files]

  Synchronize the git repository via rsync.

  Remote host and path are set via git config, like this:

    git config --local rsync.remote your_remote_host:/path/to/remote/repo

  If you transfer files via the SSH connection, it can be load the SSH
  config / SSH agent, or specify the login name and private key, like this:

    git config --local rsync.rsh "ssh -i <indentity_file> -l <login_name>"

  Exclude files are set by .gitignore.

Options:
  -n, --dry-run
              Dry run.
  -x, --exclude <pattern>
              Exclude files matching <pattern>.
  -d, --diff
              Git diff mode: push or pull new/modified files since the last
              commit.

Arguments:
  <command>   push, pull
  [files]     Push or pull individual files instead of the whole repository.
              (Cannot be used with -d.)

_EOT_
}

function err() {
    echo "$*" >&2
}

function raise() {
    if [[ $# -gt 0 ]]; then
        err "$*"
    fi
    exit 1
}

function check_cmd() {
    if ! command -v $1 >/dev/null; then
        raise "$1 is not installed, abort."
    fi
}

function parse_args() {
    argc=0
    argv=()
    excludes=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -*)
                case "$1" in
                    -h | --help)
                        usage
                        exit
                        ;;
                    -n | --dry-run)
                        dry_run="-n"
                        shift
                        ;;
                    -x | --exclude)
                        excludes=("${excludes[@]}" "--exclude=$2")
                        shift 2
                        ;;
                    -d | --diff)
                        diff="-d"
                        shift
                        ;;
                    *)
                        echo "Error: Unknown option $1.\n" >&2
                        usage
                        raise
                        ;;
                esac
                ;;
            *)
                ((++argc))
                argv=("${argv[@]}" "$1")
                shift
                ;;
        esac
    done

    if [[ $argc -lt 1 ]]; then
        usage
        raise
    fi
}

function clear_files_or_excl_file() {
    rm -f "$files_or_excl_file"
}

# Just unlikely strings that we use to delimit diff output:
DIFF_START='__git-rsync-diff-start-66334fff74fe1acf081ab594a331f86a__'
DIFF_END='__git-rsync-diff-end-66334fff74fe1acf081ab594a331f86a__'

function main() {
    check_cmd git
    check_cmd rsync

    parse_args "$@"

    local mode workdir remote_path remote_host remote_dir ssh_cmd file_opt get_f

    mode="${argv[0]}"
    unset argv[0]
    workdir="$(git rev-parse --show-toplevel)" || raise
    remote_path="$(git config --local --get rsync.remote)" || \
        raise "Please set rsync.remote via git config."

    if _rsh="$(git config --get rsync.rsh)"; then
        export RSYNC_RSH="$_rsh"
    fi

    case $mode in
        push | ps )
            local src="$workdir"
            local dst="$remote_path"
            if [[ -n "$diff" ]]; then
                function get_files() {
                    git --no-pager diff --name-only --diff-filter=AM
                }
                get_f=1
            fi
            ;;
        pull | pl )
            local src="$remote_path"
            local dst="$workdir"
            if [[ -n "$diff" ]]; then
                # TODO TODO does not work correctly
                remote_host="${remote_path%:*}"
                if [[ "$remote_host" != "$remote_path" ]]; then
                    remote_dir="${remote_path#*:}"
                fi
                if [[ "${_rsh#ssh }" != "$_rsh" ]]; then
                    ssh_cmd="$_rsh $remote_host"
                else
                    ssh_cmd="ssh $remote_host"
                fi
                function get_files() {
                    $(echo $ssh_cmd) -t \
                        << _EOT_ | awk "/^${DIFF_START}\$/{flag=1; next} \
/^$DIFF_END\$/{flag=0} flag"
cd $remote_dir
echo "$DIFF_START"
git --no-pager diff --name-only --diff-filter=AM
echo "$DIFF_END"
_EOT_
                }
                get_f=1
            fi
            ;;
        * )
            usage
            raise
            ;;
    esac
    
    if [[ "${#argv[@]}" != 0 ]]; then
        if [[ -n "$get_f" ]]; then
            raise "Cannot use -d (diff) together with filename arguments for push|pull."
        fi
        function get_files() {
            for f in "${argv[@]}"; do
                echo "$f"
            done
        }                
        get_f=1
    fi

    
    files_or_excl_file="$(mktemp)"
    trap clear_files_or_excl_file 0 2 9 15
    if [[ -n "$get_f" ]]; then
        get_files > "$files_or_excl_file"
        file_opt="--files-from=$files_or_excl_file"
    else
        # TODO bug: this works locally even for pull, but should run on the remote
        # sever similarly to get_files
        git \
            -C "$workdir" \
            ls-files \
            --exclude-standard \
            -oi \
            --directory \
            > "$files_or_excl_file"
        file_opt="--exclude-from=$files_or_excl_file"
    fi

    # -a: archive
    #   -r: recursive
    #   -l: copy symlinks as symlinks
    #   -p: preserve permissions
    #   -t: preserve times
    #   -g: preserve group
    #   -o: preserve owner
    #   --devices: preserve device files
    #   --specials: preserve special files
    # -c: skip based on checksum, not mod-time & size
    # -h: output numbers in a human-readable format
    # -u: skip files that are newer on the receiver
    # -v: increase verbosity
    # -z: compress file data during the transfer
    # -P:
    #   --progress: show progress during transfer
    #   --partial: keep partially transferred files
    rsync \
        -achuvzP $dry_run \
        "$file_opt" --exclude=".git" "${excludes[@]}" \
        "$src/" "$dst"

    clear_files_or_excl_file
}

main "$@"
