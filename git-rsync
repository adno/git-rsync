#!/usr/bin/env bash
#
# Copyright (c) 2021 Hiroyuki Deguchi
# Copyright (c) 2023 Adam Nohejl
#
# This software is released under the MIT License.
# http://opensource.org/licenses/mit-license.php

set -e

function usage() {
    cat << _EOT_ >&2
git-rsync v0.0.2 (adno)

Usage: $(basename $0) [-n] [-x <pattern>] <command> [files]

  Synchronize the git repository via rsync.

  Remote host and path are set via git config, like this:

    git config --local rsync.remote your_remote_host:/path/to/remote/repo

  If you transfer files via the SSH connection, it can be load the SSH
  config / SSH agent, or specify the login name and private key, like this:

    git config --local rsync.rsh "ssh -i <indentity_file> -l <login_name>"

  Excluded files are set automatically by .gitignore (unless individual
  file arguments are supplied).
  
  If the command is "pull", the ignored files or diff/untracked files are
  queried from the remote host over SSH (which may result in an additional
  password prompt).

Options:
  -n, --dry-run
              Dry run.
  -x, --exclude <pattern>
              Exclude files matching <pattern>.
  -d, --diff  Git diff mode: push or pull added and modified files since the last
              commit.
  -u, --diff-untracked, --update
              Git diff+untracked mode: push or pull added, modified, and untracked
              files since the last commit.

Arguments:
  <command>   push, pull
  [files]     Push or pull individual files instead of the whole repository.
              (Cannot be used with -d or -u.)

_EOT_
}

function err() {
    echo "$*" >&2
}

function raise() {
    if [[ $# -gt 0 ]]; then
        err "$*"
    fi
    exit 1
}

function check_cmd() {
    if ! command -v $1 >/dev/null; then
        raise "$1 is not installed, abort."
    fi
}

function parse_args() {
    argc=0
    argv=()
    excludes=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -*)
                case "$1" in
                    -h | --help)
                        usage
                        exit
                        ;;
                    -n | --dry-run)
                        dry_run="-n"
                        shift
                        ;;
                    -x | --exclude)
                        excludes=("${excludes[@]}" "--exclude=$2")
                        shift 2
                        ;;
                    -d | --diff)
                        if [[ -z "$diff" ]]; then
                            # Make sure -u overrides -d if both present
                            diff='A |M '
                            diff_desc='added or modified'
                        fi
                        shift
                        ;;
                    -u | --diff-untracked | --update)
                        diff='A |M |\?\?'
                        diff_desc='added, modified or untracked'
                        shift
                        ;;
                    *)
                        err "Error: Unknown option $1."
                        err ''
                        usage
                        raise
                        ;;
                esac
                ;;
            *)
                ((++argc))
                argv=("${argv[@]}" "$1")
                shift
                ;;
        esac
    done

    if [[ $argc -lt 1 ]]; then
        usage
        raise
    fi
}

function clear_files_or_excl_file() {
    rm -f "$files_or_excl_file"
}

# Just unlikely strings that we use to delimit remote command output:
OUT_START='__git-rsync-remote-output-start-66334fff74fe1acf081ab594a331f86a__'
OUT_END='__git-rsync-remote-output-end-66334fff74fe1acf081ab594a331f86a__'

function main() {
    check_cmd git
    check_cmd rsync

    parse_args "$@"

    local mode src dst workdir remote_path remote_host remote_dir rsh \
        ssh_cmd file_opt get_excl_cmd get_files_cmd get_f

    function remote_eval() {
        # TODO We assume the remote repo to be synced when executing "git status".
        # The following doesn't seem to work (even if we run and forward ssh-agentâ€¦)
        # eval \$(ssh-agent -s)
        # git pull
        local cmd="$*"
        ($ssh_cmd -t | awk "/^${OUT_START}\$/{flag=1; next} \
/^$OUT_END\$/{flag=0} flag") << _EOT_
cd $remote_dir
echo "$OUT_START"
$cmd
echo "$OUT_END"
_EOT_
    }

    mode="${argv[0]}"
    unset argv[0]
    workdir="$(git rev-parse --show-toplevel)" || raise
    remote_path="$(git config --local --get rsync.remote)" || \
        raise "Please set rsync.remote via git config."
    
    get_files_cmd="git status --porcelain | sed -Ene 's/^($diff) //p'"    
    get_excl_cmd="git -C \"$workdir\" ls-files \
--exclude-standard -oi --directory"
    remote_get_excl_cmd="git ls-files --exclude-standard -oi --directory"

    if rsh="$(git config --get rsync.rsh)"; then
        export RSYNC_RSH="$rsh"
    fi
    case $mode in
        push | ps )
            src="$workdir"
            dst="$remote_path"
            if [[ -n "$diff" ]]; then
                function get_files() { eval "$get_files_cmd"; }
                get_f=1
            else
                function get_excl() { eval "$get_excl_cmd"; }
            fi
            ;;
        pull | pl )
            src="$remote_path"
            dst="$workdir"
            remote_host="${remote_path%:*}"
            if [[ "$remote_host" != "$remote_path" ]]; then
                remote_dir="${remote_path#*:}"
            fi
            if [[ "${rsh#ssh }" != "$rsh" ]]; then
                ssh_cmd="$rsh $remote_host"
            else
                ssh_cmd="ssh $remote_host"
            fi
            if [[ -n "$diff" ]]; then
                function get_files() { remote_eval "$get_files_cmd"; }
                get_f=1
            else
                function get_excl() { remote_eval "$remote_get_excl_cmd"; }
            fi
            ;;
        * )
            usage
            raise
            ;;
    esac
    
    
    if [[ "${#argv[@]}" != 0 ]]; then
        if [[ -n "$get_f" ]]; then
            raise "Cannot use -d (diff) together with filename arguments for push|pull."
        fi
        function get_files() {
            for f in "${argv[@]}"; do
                echo "$f"
            done
        }                
        get_f=1
    fi
    
    files_or_excl_file="$(mktemp)"
    trap clear_files_or_excl_file 0 2 9 15
    if [[ -n "$get_f" ]]; then
        get_files > "$files_or_excl_file"
        file_opt="--files-from=$files_or_excl_file"
    else
        get_excl > "$files_or_excl_file"
        file_opt="--exclude-from=$files_or_excl_file"
    fi

    if [[ -n "$get_f" ]] && ! [[ -s "$files_or_excl_file" ]] ; then
        # Avoid running rsync unnecessarily:
        err ''
        err "Already up to date. No $diff_desc files found."
    else
        # -a: archive
        #   -r: recursive
        #   -l: copy symlinks as symlinks
        #   -p: preserve permissions
        #   -t: preserve times
        #   -g: preserve group
        #   -o: preserve owner
        #   --devices: preserve device files
        #   --specials: preserve special files
        # -c: skip based on checksum, not mod-time & size
        # -h: output numbers in a human-readable format
        # -u: skip files that are newer on the receiver
        # -v: increase verbosity
        # -z: compress file data during the transfer
        # -P:
        #   --progress: show progress during transfer
        #   --partial: keep partially transferred files
        rsync \
            -achuvzP $dry_run \
            "$file_opt" --exclude=".git" "${excludes[@]}" \
            "$src/" "$dst"
    fi

    clear_files_or_excl_file
}

main "$@"
