#!/usr/bin/env bash
#
# Copyright (c) 2021 Hiroyuki Deguchi
# Copyright (c) 2023-4 Adam Nohejl
#
# This software is released under the MIT License.
# http://opensource.org/licenses/mit-license.php

set -e

function usage() {
    if [[ -n "$1" ]]; then
        err "$1"
        err ''
    fi
    cat << _EOT_ >&2
git-rsync v0.0.3 (adno)

Usage: $(basename $0) [-n] [-x <pattern>] <command> [files]

  Synchronize the git repository via rsync.

  Remote host and path are set via git config. Local (per-repository)
  configuration can be done in the following way:

    git config --local rsync.remote your_remote_host:/path/to/remote/repo

  If you transfer files via the SSH connection, it can be load the SSH
  config / SSH agent, or specify the login name and private key, like this:

    git config --local rsync.rsh "ssh -i <indentity_file> -l <login_name>"

  To configure globally (per user), without repository specific settings use:
  
    git config --global rsync.remoteprefix your_remote_host:/pathprefix
    git config --global rsync.rsh "ssh -i <indentity_file> -l <login_name>"

  The remote path is then composed as rsync.remoteprefix/local_repo_name.
  Only the last component of the local repo path is used as local_repo_name.
  A local rsync.remote setting overrides any rsync.remoteprefix setting.

  Excluded files are set automatically by .gitignore (unless individual
  file arguments are supplied).
  
  If the command is "pull", the ignored files or diff/untracked files are
  queried from the remote host over SSH (which may result in an additional
  password prompt).

Options:
  -n, --dry-run
              Dry run.
  -x, --exclude <pattern>
              Exclude files matching <pattern>.
  -s, --staged, -c, --cached
              Push or pull added and modified files staged for commit
              (mimicks output "git diff --cached").
  -u, --update
              Push or pull added, modified, and untracked files since the
              last commit (mimicks "git status").
  -f, --force
              Force overwrite newer files. (By default files that are
              newer on the receiver are skipped during sync.)

Arguments:
  <command>   push, pull
  [files]     Push or pull individual files instead of the whole repository.
              If directories are supplied, sync them recursively. Honors -x,
              ignores .gitignore, and cannot be used with -d or -u.

_EOT_
}

function err() {
    echo "$*" >&2
}

function raise() {
    if [[ $# -gt 0 ]]; then
        err "$*"
    fi
    exit 1
}

function check_cmd() {
    if ! command -v $1 >/dev/null; then
        raise "$1 is not installed, abort."
    fi
}

# The following are regexes:
SHORT_OPTS='^[hnxscuf]$'
LONG_OPTS='^--(help|dry-run|exclude|staged|cached|update|force)$'
SHORT_OPTS_WITH_ARG='^x$'
LONG_OPTS_WITH_ARG='^--exclude$'
CMDS='^(push|pull|ps|pl)$'

# TODO parse/check options including strings of single-letter
# function parse_args() {
#     local opt opt_info cmd i
#     args=()
#     while [[ $# -gt 0 ]]; do
#         case "$1" in
#             --*)
#                 if [[ "$1" =~ '=' ]]; then
#                     opt="${1%%=*}"
#                     if ! [[ "$opt" =~ $LONG_OPTS_WITH_ARG ]]; then
#                         usage "Unexpected = (argument) after $opt."
#                         exit 1
#                     fi
#                     args=("${args[@]}" "$opt" "${1#*=}")
#                     shift 1
#                 elif [[ "$1" =~ $LONG_OPTS_WITH_ARG ]]; then
#                     if [[ $# -lt 2 ]]; then
#                         usage "Missing argument after option $1."
#                     fi
#                     args=("${args[@]}" "$1" "$2")
#                     shift 2                    
#                 elif [[ "$1" =~ $LONG_OPTS ]]; then
#                     args=("${args[@]}" "$1")
#                     shift 1
#                 else
#                     usage "Unknown long option $1."
#                     exit 1
#                 fi
#                 ;;
#             -*)
#                 if [[ ${#1} -gt 2 ]]; then
#                     opt_info=" in $1"
#                 else
#                     opt_info=''
#                 fi
#                 for (( i=1; i<${#1}; i++ )); do
#                     opt="${1:$i:1}"
#                     echo "opt $opt"
#                     if ! [[ "$opt" =~ $SHORT_OPTS ]]; then
#                         usage "Unknown short option -$opt$opt_info."
#                         exit 1
#                     elif [[ "$opt" =~ $SHORT_OPTS_WITH_ARG ]]; then
#                         arg="${1:$(($i+1)):1}"
#                         if [[ -n "$arg" ]]; then
#                             args=("${args[@]}" "-$opt" "$arg")
#                         else
#                             if [[ $# -lt 2 ]]; then
#                                 usage "Missing argument after option -$opt$opt_info."
#                                 exit 1
#                             fi
#                             args=("${args[@]}" "-$opt" "$2")
#                             shift 1
#                         fi
#                         break
#                     else
#                         echo "args += opt $opt"
#                         args=("${args[@]}" "-$opt")
#                     fi
#                 done
#                 shift 1
#                 ;;
#             *)
#                 # Ensure the first non-option arguments is a command:
#                 if [[ -z "$cmd" ]]; then
#                     if ! [[ "$1" =~ $CMDS ]]; then
#                         usage "Invalid command $1."
#                         exit 1
#                     fi
#                     cmd="$1"
#                 fi
#                 args=("${args[@]}" "$1")
#                 shift 1
#                 ;;
#         esac
#     done
# }


function parse_args() {
    argc=0
    argv=()
    excludes=()
    u_opt='u'
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -*)
                case "$1" in
                    -h | --help)
                        usage
                        exit
                        ;;
                    -n | --dry-run)
                        dry_run="-n"
                        shift
                        ;;
                    -x | --exclude)
                        excludes=("${excludes[@]}" "--exclude=$2")
                        shift 2
                        ;;
                    -s | --staged | -c | --cached)
                        if [[ -z "$diff" ]]; then
                            # Make sure -u overrides -s if both present
                            diff='[AM] '
                            diff_desc='staged added or modified'
                        fi
                        shift
                        ;;
                    -u | --update)
                        diff='[AM] | [AM]|\?\?'
                        diff_desc='added, modified or untracked'
                        shift
                        ;;
                    -f | --force)
                        # Disable the -u option:
                        u_opt=''
                        shift
                        ;;
                    *)
                        usage "Unknown option $1."
                        exit 1
                        ;;
                esac
                ;;
            *)
                ((++argc))
                argv=("${argv[@]}" "$1")
                shift
                ;;
        esac
    done

    if [[ $argc -lt 1 ]]; then
        usage
        raise
    fi
}

function clear_files_or_excl_file() {
    rm -f "$files_or_excl_file"
}

# Just unlikely strings that we use to delimit remote command output:
OUT_START='__git-rsync-remote-output-start-66334fff74fe1acf081ab594a331f86a__'
OUT_END='__git-rsync-remote-output-end-66334fff74fe1acf081ab594a331f86a__'

function main() {
    check_cmd git
    check_cmd rsync

    parse_args "$@"

    local mode src dst workdir remote_path remote_host remote_dir rsh \
        ssh_cmd file_opt get_excl_cmd get_files_cmd get_f recursive

    function remote_eval() {
        # TODO We assume the remote repo to be synced when executing "git status".
        # The following doesn't seem to work (even if we run and forward ssh-agentâ€¦)
        # eval \$(ssh-agent -s)
        # git pull
        local cmd="$*"
        ($ssh_cmd -t | awk "/^${OUT_START}\$/{flag=1; next} \
/^$OUT_END\$/{flag=0} flag") << _EOT_
cd $remote_dir
echo "$OUT_START"
$cmd
echo "$OUT_END"
_EOT_
    }

    mode="${argv[0]}"
    unset argv[0]
    workdir="$(git rev-parse --show-toplevel)" || raise "Cannot get workdir."
    if remote_path="$(git config --local --get rsync.remote)"; then
        # Safety check:
        if [ -z "$remote_path" ]; then
            raise "Git config rsync.remote set but empty."
        fi
    else
        if ! remote_prefix="$(git config --get rsync.remoteprefix)"; then
            raise "Please set rsync.remote or rsync.remoteprefix via git config."
        fi
        # Safety check:
        if [ -z "$remote_prefix" ]; then    
            raise "Git config rsync.remoteprefix set but empty."
        fi
        # Remove trailing '/' if present:
        if [ "${remote_prefix}" != "${remote_prefix%/}" ]; then    
            remote_prefix="${remote_prefix%/}"
        fi
        repo_name="${workdir##*/}"
        remote_path="${remote_prefix}/${repo_name}"
    fi
    
    
    get_files_cmd="git status --porcelain | sed -Ene 's/^($diff) //p'"    
    get_excl_cmd="git -C \"$workdir\" ls-files \
--exclude-standard -oi --directory"
    remote_get_excl_cmd="git ls-files --exclude-standard -oi --directory"

    if rsh="$(git config --get rsync.rsh)"; then
        export RSYNC_RSH="$rsh"
    fi
    case $mode in
        push | ps )
            src="$workdir"
            dst="$remote_path"
            if [[ -n "$diff" ]]; then
                function get_files() { eval "$get_files_cmd"; }
                get_f=1
            else
                function get_excl() { eval "$get_excl_cmd"; }
            fi
            ;;
        pull | pl )
            src="$remote_path"
            dst="$workdir"
            remote_host="${remote_path%:*}"
            if [[ "$remote_host" != "$remote_path" ]]; then
                remote_dir="${remote_path#*:}"
            fi
            if [[ "${rsh#ssh }" != "$rsh" ]]; then
                ssh_cmd="$rsh $remote_host"
            else
                ssh_cmd="ssh $remote_host"
            fi
            if [[ -n "$diff" ]]; then
                function get_files() { remote_eval "$get_files_cmd"; }
                get_f=1
            else
                function get_excl() { remote_eval "$remote_get_excl_cmd"; }
            fi
            ;;
        * )
            usage
            raise
            ;;
    esac
    
    
    if [[ "${#argv[@]}" != 0 ]]; then
        if [[ -n "$get_f" ]]; then
            raise "Cannot use --staged/--update together with filename arguments for \
push|pull."
        fi
        function get_files() {
            for f in "${argv[@]}"; do
                echo "$f"
            done
        }                
        get_f=1
        # --files-from turns off -r ("recursive", implied by -a) by default
        recursive='-r'
    fi
    
    files_or_excl_file="$(mktemp)"
    trap clear_files_or_excl_file 0 2 9 15
    if [[ -n "$get_f" ]]; then
        get_files > "$files_or_excl_file"
        file_opt="--files-from=$files_or_excl_file"
    else
        get_excl > "$files_or_excl_file"
        file_opt="--exclude-from=$files_or_excl_file"
    fi

    if [[ -n "$get_f" ]] && ! [[ -s "$files_or_excl_file" ]] ; then
        # Avoid running rsync unnecessarily:
        err ''
        err "Already up to date. No $diff_desc files found."
    else
        # -a: archive
        #   -r: recursive (except with --files-from)
        #   -l: copy symlinks as symlinks
        #   -p: preserve permissions
        #   -t: preserve times
        #   -g: preserve group
        #   -o: preserve owner
        #   --devices: preserve device files
        #   --specials: preserve special files
        # -c: skip based on checksum, not mod-time & size
        # -h: output numbers in a human-readable format
        # -u: skip files that are newer on the receiver
        # -v: increase verbosity
        # -z: compress file data during the transfer
        # -P:
        #   --progress: show progress during transfer
        #   --partial: keep partially transferred files
        rsync \
            -ach${u_opt}vzP $dry_run $recursive \
            "$file_opt" --exclude=".git" "${excludes[@]}" \
            "$src/" "$dst"
    fi

    clear_files_or_excl_file
}

main "$@"
